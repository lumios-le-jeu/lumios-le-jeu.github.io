<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lumios ‚Äì web proto</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#131a3a;
    --brand:#e65a6a;
    --green:#38d67a;
    --blue:#4da6ff;
    --red:#ff5a67;
    --gold:#ffd24a;
    --text:#fff;
    --hudH:56px;           /* hauteur du HUD */
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Arial,Helvetica,sans-serif;height:100%;}
  * { touch-action: manipulation; }

  #hud{
    position:fixed; inset:0 0 auto 0; height:var(--hudH);
    padding:8px calc(12px + env(safe-area-inset-right)) 8px calc(12px + env(safe-area-inset-left));
    display:flex; align-items:center; gap:12px;
    background:rgba(5,10,25,.65); backdrop-filter:blur(8px);
    z-index:50;
  }

  #clock{ font-weight:700; letter-spacing:.5px; }
  #powerRow{ display:flex; align-items:center; gap:0px; margin-left:12px; }
  #powerTrack{ width:100px; height:10px; background:#121836; border-radius:999px; overflow:hidden }
  #powerFill{ height:100%; width:0%; background:#4da6ff; }

  #labelPow{ margin-left:8px; opacity:.85; }
  #powWrap{ width:140px; height:10px; background:#121836; border-radius:999px; overflow:hidden; margin:0 8px; }
  #powBar{ height:100%; width:0%; background:#4da6ff; }
  #powPct{ font-weight:700; }

  #hamburger{
    width:40px; height:40px; border-radius:10px;
    border:2px solid rgba(255,255,255,.15);
    background:rgba(255,255,255,.08); color:#fff; font-size:20px; font-weight:800;
    display:inline-flex; align-items:center; justify-content:center;
    margin-right:8px;
  }

  .menu{
    position:fixed; top:var(--hudH); left:0; right:0;
    max-height:0; overflow:hidden;
    background:rgba(10,14,30,.95);
    transition:max-height .25s ease;
    z-index:60; padding:0 12px;
  }
  .menu.open{ max-height:70vh; }
  .menu-row{
    display:flex; align-items:center; gap:10px;
    padding:10px 4px; border-bottom:1px solid rgba(255,255,255,.08);
  }
  .menu .track{ flex:1; height:10px; background:#121836; border-radius:999px; overflow:hidden; }
  .menu .fill{ height:100%; width:0%; background:var(--blue); }
  .menu-actions{ display:grid; grid-template-columns:1fr 1fr; gap:8px; padding:12px 0; }
  .menu .btn{ padding:10px 12px; border-radius:8px; font-weight:700; border:none; box-shadow:0 6px 16px rgba(0,0,0,.25); }
  .menu .buy{ grid-column:1/-1; text-align:center; text-decoration:none; background:#ff4d6d; color:#fff; }

  #badge{
    margin-left:auto;
    max-width:45vw;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    font-weight:800; font-size:16px;
    padding:8px 12px; border-radius:10px;
    color:#000; background:#6ab7ff;
    border:2px solid rgba(255,255,255,.15);
  }

  #wrap{ position:relative; width:100vw; height:100vh; }
  #canvas{
    position:absolute; inset:56px 0 0 0;
    display:block; width:100%; height:calc(100% - 56px);
    touch-action: pan-y;
  }

  #panel{ display:none !important; }

  .card{background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 6px 16px rgba(0,0,0,.25);margin-bottom:8px}
  #brand { display:block; background:var(--brand); color:#fff; font-weight:bold; font-size:20px; letter-spacing:2px; text-align:center; border-radius:10px; text-decoration:none; }
  .row{display:flex;justify-content:space-between;align-items:center;font-size:14px}
  .dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:6px}
  .g{background:var(--green)} .b{background:var(--blue)}
  .btn{display:block;width:100%;margin-top:6px;padding:10px 12px;border-radius:8px;text-align:center;font-weight:bold;cursor:pointer;box-shadow:0 6px 16px rgba(0,0,0,.25);border:none}
  #btnMode,#mBtnMode{background:var(--green);color:#000}
  #btnNext,#mBtnNext{background:#ffb74a;color:#000}
  #btnReplay,#mBtnReplay{background:var(--blue);color:#fff}
  #btnBuy{display:block;width:100%;margin-top:6px;padding:12px;border-radius:10px;text-align:center;font-weight:700;background:#ff4d6d;color:#fff;text-decoration:none;box-shadow:0 6px 16px rgba(0,0,0,.25)}
  #btnBuy:hover{filter:brightness(1.08)}
  #modeSelect.btn, #mModeSelect.btn { -webkit-appearance:none; appearance:none; background:#222a56; color:#fff; font-weight:700; }

  @media (max-width: 768px){
    #badge{ font-size:14px; padding:6px 10px; border-radius:8px; max-width:54vw; }
  }

  #narration{
    position:fixed; right:12px; bottom:12px; max-width:460px;
    background:rgba(10,14,30,.92); border:1px solid rgba(255,255,255,.12);
    border-radius:10px; padding:10px 12px; box-shadow:0 6px 16px rgba(0,0,0,.25); z-index:40;
    font-size:14px; line-height:1.35;
  }
  @media (max-width:768px){ #narration{ display:none; } }

  #help{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:110px; color:#fff; opacity:.9; text-shadow:0 2px 8px rgba(0,0,0,.6);
    font-weight:700; font-size:18px; pointer-events:none;
  }
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <button id="hamburger" aria-label="Menu">‚ò∞</button>
  <div id="clock">00:00</div>
  <div id="labelPow">Power</div>
  <div id="powWrap"><div id="powBar"></div></div>
  <div id="powPct">0%</div>
  <div id="badge">JOUEUR 1</div>
</div>

<!-- Menu d√©roulant -->
<div id="dropMenu" class="menu">
  <div class="menu-row">
    <span class="label">Power</span>
    <div class="track"><div class="fill" id="menuPowFill"></div></div>
    <b id="menuPowPct">0%</b>
  </div>
  <div class="menu-row">
    <span class="dot g"></span><span>Verts</span><b id="mCntG">0</b>
  </div>
  <div class="menu-row">
    <span class="dot b"></span><span>Bleus</span><b id="mCntB">0</b>
  </div>
  <div class="menu-row" style="gap:8px;">
    <select id="mModeSelect" class="btn">
      <option value="pvp">2 Joueurs</option>
      <option value="easy">Solo vs Robot (Facile)</option>
      <option value="hard">Solo vs Robot (Difficile)</option>
    </select>
  </div>
  <div class="menu-actions">
    <button id="mBtnMode"   class="btn">üåô Nuit</button>
    <button id="mBtnNext"   class="btn">‚è≠Ô∏è Skip</button>
    <button id="mBtnReplay" class="btn">üîÑ Rejouer</button>
    <a class="btn buy" href="https://www.lumios-le-jeu.fr/" target="_blank" rel="noopener">
      üéÅ Pr√©commander un vrai Jeu Lumios pour No√´l
    </a>
    <a class="btn buy" style="background:#e65a6a"
       href="https://www.lumios-le-jeu.fr/pages/regles-du-jeu-lumios" target="_blank" rel="noopener">üìñ R√®gles</a>
  </div>
</div>

<!-- Zone de jeu -->
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="help">Lancez la balle en visant les boules</div>
</div>

<!-- Panneau (masqu√©) -->
<div id="panel">
  <a id="brand" class="card" href="https://www.lumios-le-jeu.fr/pages/regles-du-jeu-lumios" target="_blank" rel="noopener">R√®gles</a>
  <div class="card">
    <div class="row"><span><span class="dot g"></span>Verts</span><b id="cntG">0</b></div>
    <div class="row"><span><span class="dot b"></span>Bleus</span><b id="cntB">0</b></div>
  </div>
  <select id="modeSelect" class="btn">
    <option value="pvp">2 Joueurs</option>
    <option value="easy">Solo vs Robot (Facile)</option>
    <option value="hard">Solo vs Robot (Difficile)</option>
  </select>
  <button id="btnMode" class="btn">üåô Nuit</button>
  <button id="btnNext" class="btn">‚è≠Ô∏è Skip</button>
  <button id="btnReplay" class="btn">üîÑ Rejouer</button>
  <a id="btnBuy" href="https://www.lumios-le-jeu.fr/" target="_blank" rel="noopener">üéÅ Pr√©commander un vrai Jeu Lumios pour No√´l</a>
</div>

<!-- Narration -->
<div id="narration" aria-live="polite"></div>

<script>
/* ===== Polyfill rAF ===== */
(function(){
  var v=['ms','moz','webkit','o'],i;
  for(i=0;i<v.length && !window.requestAnimationFrame;i++){
    window.requestAnimationFrame=window[v[i]+'RequestAnimationFrame'];
    window.cancelAnimationFrame=window[v[i]+'CancelAnimationFrame']||window[v[i]+'CancelRequestAnimationFrame'];
  }
  if(!window.requestAnimationFrame){
    window.requestAnimationFrame=function(cb){return setTimeout(function(){cb(Date.now());},16);};
    window.cancelAnimationFrame=function(id){clearTimeout(id);};
  }
})();

/* ===== Canvas & UI refs ===== */
const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
const hudClock=document.getElementById('clock');
const powBar=document.getElementById('powBar');
const powPct=document.getElementById('powPct');
const badge=document.getElementById('badge');
const elCntG=document.getElementById('cntG'), elCntB=document.getElementById('cntB');
const narrationEl=document.getElementById('narration');
const helpEl=document.getElementById('help');

/* Menu */
const hamburger = document.getElementById('hamburger');
const dropMenu  = document.getElementById('dropMenu');
const mPowFill  = document.getElementById('menuPowFill');
const mPowPct   = document.getElementById('menuPowPct');
const mCntG     = document.getElementById('mCntG');
const mCntB     = document.getElementById('mCntB');
hamburger.onclick = () => dropMenu.classList.toggle('open');
document.getElementById('mBtnMode').onclick   = () => btnMode.click();
document.getElementById('mBtnNext').onclick   = () => document.getElementById('btnNext').click();
document.getElementById('mBtnReplay').onclick = () => document.getElementById('btnReplay').click();

/* Sizing */
function sizeCanvas(){
  const r=canvas.getBoundingClientRect();
  canvas.width = Math.max(1, Math.floor(r.width));
  canvas.height= Math.max(1, Math.floor(r.height));
  layout();
}
window.addEventListener('resize', sizeCanvas);

/* Colors */
const COLOR_RED   ='#ff5a67';
const COLOR_GREEN ='#38d67a';
const COLOR_BLUE  ='#4da6ff';
const COLOR_GOLD  = '#ffd24a';

/* Params */
const LUMIES_N=5, R_LUMIE=22, R_BALL=25;
const LUMIE_SPACING = R_LUMIE * 4;
const RESTIT=0.95, FRICTION=0.992, ROLL_F=0.98;
const POWER_K=0.09, MAX_DRAG=320;
const MAX_AIM_LEN = 120;
const BASE_ZONE_RATIO=0.16;
const MOVE_EPS = 0.0005;
const COLOR_COOLDOWN = 4000; // 4 s
const IMPACT_MIN = 0.01; // puissance mini pour compter un impact


// --- confort mobile ---
const MOBILE = window.innerWidth <= 768;
const MOBILE_LAUNCH_MARGIN = 120;   // marge minimale au bas/haut de l‚Äô√©cran pour placer la balle
const TAP_SLOP = 22;                // tol√©rance pour attraper la balle (pixels)


/* State */
let lumies=[], ball=null, drag=null, tStart=Date.now();
let mode="night";
let currentPlayer=1;
let playerColors={1:null,2:null};
let gameOver=false, winColor=null, confetti=[];
let showHint = true;
let changesThisTurn=[]; // [{before,after}]
let startColors=[];     // snapshot au d√©but du tour

/* ‚ÄúBALLE DE LUMIOS‚Äù */
let lumiosBallUntil = 0;

/* Game mode */
let gameMode = "pvp";
const modeSelect = document.getElementById('modeSelect');
const mModeSelect = document.getElementById('mModeSelect');
function syncModeSelects(val){
  if(modeSelect) modeSelect.value = val;
  if(mModeSelect) mModeSelect.value = val;
}
if(mModeSelect){
  mModeSelect.onchange = function(){
    gameMode = this.value; syncModeSelects(gameMode); resetGame();
  };
}
if(modeSelect){
  modeSelect.onchange = function(){
    gameMode = this.value; syncModeSelects(gameMode); resetGame();
  };
}

/* UI */
const btnMode=document.getElementById('btnMode');
btnMode.onclick=function(){
  if(mode==="night"){ mode="day"; btnMode.textContent="‚òÄÔ∏è Jour"; btnMode.style.background=COLOR_BLUE; btnMode.style.color="#fff"; }
  else { mode="night"; btnMode.textContent="üåô Nuit"; btnMode.style.background=COLOR_GREEN; btnMode.style.color="#000"; }
};
document.getElementById('btnNext').onclick=function(){
  if(ball){ ball.active=false; ball.vx=0; ball.vy=0; }
  endOfTurn();
};
document.getElementById('btnReplay').onclick=function(){ resetGame(); };

function countColors(){let g=0,b=0;for(let i=0;i<lumies.length;i++){const c=lumies[i].color; if(c==='green')g++; else if(c==='blue')b++;}return {g,b};}
function updateScore(){
  const c = countColors(); 
  elCntG.textContent=c.g; 
  elCntB.textContent=c.b;
  mCntG.textContent=c.g; 
  mCntB.textContent=c.b;

  // ‚úÖ Seulement si 4 d‚Äôune couleur
  if(c.g===4 || c.b===4){ 
    lumiosBallUntil = performance.now() + 1600; 
  }
}
   

/* Init */
function resetGame(){
  playerColors={1:null,2:null};
  currentPlayer=1;
  gameOver=false; winColor=null; confetti.length=0;
  tStart=Date.now(); showHint = true;
  narrationEl.textContent=''; changesThisTurn.length=0;
  layout();
  startTurn(); // snapshot + unlock
}

function layout(){
  lumies=[];
  const midX=canvas.width*0.5, midY=canvas.height*0.5;

  let spacing=LUMIE_SPACING, startX=midX - spacing*(LUMIES_N-1)/2;
  const isMobile=(canvas.width<=768) || (window.innerHeight>window.innerWidth);
  if(isMobile){
    const marginX=Math.max(16, canvas.width*0.06);
    const usable = canvas.width - 2*(marginX + R_LUMIE);
    const fitSpacing = (LUMIES_N>1)? (usable/(LUMIES_N-1)) : 0;
    spacing = Math.min(LUMIE_SPACING, fitSpacing);
    const rowW = spacing*(LUMIES_N-1);
    startX = Math.max(marginX + R_LUMIE, midX - rowW/2);
  }

  for(let i=0;i<LUMIES_N;i++){
    const x=startX + i*spacing;
    //lumies.push({x, y:midY, vx:0, vy:0, r:R_LUMIE, color:'red', lastHit:0, locked:false});
    lumies.push({ x, y: midY, vx:0, vy:0, r:R_LUMIE, color:'red',lastHit:0, colorLockUntil:0 });

  }

  //const launchOffset = Math.max(56, canvas.height*0.14);
  // assez haut/bas pour rester cliquable malgr√© la barre iOS/Android
  const launchOffset = MOBILE
    ? Math.max(80, MOBILE_LAUNCH_MARGIN)
    : Math.max(56, canvas.height * 0.14);

  if(currentPlayer===1){
    ball={x:midX, y:canvas.height-launchOffset, vx:0, vy:0, r:R_BALL, active:false, age:0};
  }else{
    ball={x:midX, y:launchOffset, vx:0, vy:0, r:R_BALL, active:false, age:0};
  }

  updateScore();
  updateBadge();
}

function updateBadge(){
  if(!playerColors[1]){
    badge.style.background = COLOR_BLUE;
    badge.textContent = (window.innerWidth<=420)?("J"+currentPlayer):("JOUEUR "+currentPlayer);
    return;
  }
  const meCol = playerColors[currentPlayer];
  badge.style.background = (meCol==='green')?COLOR_GREEN:COLOR_BLUE;
  const tag = (window.innerWidth<=420)?("J"+currentPlayer):("JOUEUR "+currentPlayer);
  badge.textContent = tag+" - "+meCol.toUpperCase();
}

/* Turn helpers */
function startTurn(){
  // snapshot et d√©verrouillage des lumies
  startColors = lumies.map(l => l.color);
  changesThisTurn.length = 0;
  for(const L of lumies){ L.locked = false; L.lastHit = 0; }
}

function computeGainedLost(forPlayer){
  let gained=0, lost=0;
  const myCol = playerColors[forPlayer];
  if(!myCol) return {gained:0,lost:0};
  for(let i=0;i<lumies.length;i++){
    const before = startColors[i];
    const after  = lumies[i].color;
    if(after===myCol && before!==myCol) gained++;
    if(before===myCol && after!==myCol) lost++;
  }
  return {gained, lost};
}

/* Input */
function getPos(e){const r=canvas.getBoundingClientRect(); let x,y;
  if(e.touches&&e.touches.length){x=e.touches[0].clientX-r.left;y=e.touches[0].clientY-r.top;}
  else{x=e.clientX-r.left;y=e.clientY-r.top;} return {x,y};}

function inBaseZone(y){
  // zone de d√©part: ratio OU marge fixe (mobile) -> on prend le plus grand
  const zoneRatio = canvas.height * BASE_ZONE_RATIO;
  const zoneFixed = MOBILE ? (MOBILE_LAUNCH_MARGIN + R_BALL * 2) : 90;
  const zone = Math.max(zoneRatio, zoneFixed);

  return currentPlayer === 1
    ? (y > canvas.height - zone)   // J1 en bas
    : (y < zone);                  // J2 en haut
}


canvas.addEventListener('mousedown',startDrag,{passive:false});
canvas.addEventListener('touchstart',startDrag,{passive:false});

function startDrag(e){
  if(gameOver) return;
  if(gameMode!=='pvp' && currentPlayer===2) return;
  const p=getPos(e);
  // si on touche directement la balle: on autorise toujours
  if (ball && !gameOver) {
    const dx = p.x - ball.x, dy = p.y - ball.y;
    if (Math.hypot(dx,dy) <= R_BALL + TAP_SLOP) {
      e.preventDefault();
      drag = { sx: p.x, sy: p.y, x: p.x, y: p.y };
      helpEl.style.display = 'none';
      return;
    }
  }
  if(!inBaseZone(p.y)) return;
  e.preventDefault();
  drag={sx:p.x,sy:p.y,x:p.x,y:p.y};
  helpEl.style.display = 'none';
}

canvas.addEventListener('mousemove',moveDrag,{passive:false});
canvas.addEventListener('touchmove',moveDrag,{passive:false});
function moveDrag(e){
  if(!drag) return;
  const p=getPos(e); drag.x=p.x; drag.y=p.y; updatePowerUI(drag);
}

canvas.addEventListener('mouseup',endDrag); canvas.addEventListener('mouseleave',endDrag);
canvas.addEventListener('touchend',endDrag);
function endDrag(e){
  if(!drag) return;
  let vx=drag.x-drag.sx, vy=drag.y-drag.sy, len=Math.hypot(vx,vy);
  if(len>5){
    const p=Math.min(len,MAX_DRAG);
    const ux=vx/len, uy=vy/len;
    const speed=p*POWER_K;
    ball.x=drag.sx; ball.y=drag.sy;
    ball.vx=ux*speed; ball.vy=uy*speed;
    ball.active=true; ball.age=0;
    showHint = false;
  }
  drag=null; updatePowerUI(null);
}

function updatePowerUI(d){
  if(!d){
    powPct.textContent='0%'; powBar.style.width='0%'; powBar.style.background=COLOR_BLUE;
    mPowPct.textContent='0%'; mPowFill.style.width='0%'; mPowFill.style.background=COLOR_BLUE;
    return;
  }
  let vx=d.x-d.sx, vy=d.y-d.sy, len=Math.hypot(vx,vy), p=Math.min(len,MAX_DRAG);
  const pct=Math.round((p/MAX_DRAG)*100);
  const col = pct<40?COLOR_BLUE:(pct<75?COLOR_GREEN:'#ffb74a');
  powPct.textContent=pct+'%'; powBar.style.width=pct+'%'; powBar.style.background=col;
  mPowPct.textContent=pct+'%'; mPowFill.style.width=pct+'%'; mPowFill.style.background=col;
}

/* Color rules with per-turn lock */
function onLumieHit(L){
  if(L.locked) return; // üîí d√©j√† chang√©e ce tour

  const before = L.color;

  if (before==='red'){
    L.color = (Math.random()<0.5)?'green':'blue';
    if(!playerColors[1] && !playerColors[2]){
      playerColors[currentPlayer] = L.color;
      playerColors[(currentPlayer===1)?2:1] = (L.color==='green')?'blue':'green';
      updateBadge();
    }
  } else if (before==='green'){
    L.color = 'blue';
  } else if (before==='blue'){
    L.color = 'green';
  }

  const after = L.color;

  // m√©morise le changement pour la narration
  changesThisTurn.push({before, after});

  // lock pour le reste du tour
  L.locked = true;
  L.colorLockUntil = performance.now() + COLOR_COOLDOWN; // ‚Üê verrou 4 s

  updateScore();
  checkWin();
}

/* cooldown + mouvement */
function tryToggleOnMove(L){
  if(L.locked) return; // üîí
  const now=performance.now();
  if(!L.lastHit) L.lastHit=0;
  if(now-L.lastHit < COLOR_COOLDOWN) return;
  if(Math.hypot(L.vx,L.vy) < MOVE_EPS) return;
  onLumieHit(L);
  L.lastHit = now;
}

/* Win */
function checkWin(){const c=countColors(); if(c.g===LUMIES_N) triggerWin('green'); else if(c.b===LUMIES_N) triggerWin('blue');}
function triggerWin(c){
  gameOver=true; winColor=c; if(ball){ball.active=false; ball.vx=ball.vy=0;}
  spawnConfetti(220,c);
}
function spawnConfetti(n,c){
  confetti.length=0;
  const cx=canvas.width/2, cy=canvas.height/2;
  const base=(c==='green')?COLOR_GREEN:COLOR_BLUE;
  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2, sp=3+Math.random()*5;
    const clr=(Math.random()<.15)?'#ffffff':base;
    confetti.push({x:cx,y:cy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1,life:120+Math.random()*60,clr, size:2+Math.random()*3, rot:Math.random()*Math.PI});
  }
}
function stepConfetti(){
  for(let i=confetti.length-1;i>=0;i--){
    const p=confetti[i]; p.vy+=0.12; p.vx*=0.992; p.vy*=0.992; p.x+=p.vx; p.y+=p.vy; p.rot+=0.1; p.life--;
    if(p.life<=0) confetti.splice(i,1);
  }
}

/* Physics */
function step(){
  stepConfetti();

  const STOP_EPS = 0.04; // seuil d'arr√™t

  // === Balle jaune ===
  if (ball && ball.active){
    // int√©gration + frottements
    ball.x += ball.vx;
    ball.y += ball.vy;
    ball.vx *= FRICTION;
    ball.vy *= FRICTION;
    ball.age += 16;

    // murs G/D : rebond
    if (ball.x < ball.r){ ball.x = ball.r; ball.vx = -ball.vx * RESTIT; }
    if (ball.x > canvas.width - ball.r){ ball.x = canvas.width - ball.r; ball.vx = -ball.vx * RESTIT; }

    // haut/bas : sortie ‚Üí fin de tour
    if (ball.y < -R_BALL || ball.y > canvas.height + R_BALL){
      ball.active = false;
      endOfTurn();
    } else {
      // collisions balle ‚Üî lumies (les bascules couleur se font dans collideBallLumie via tryToggleOnImpact)
      for (let i=0;i<lumies.length;i++) collideBallLumie(ball, lumies[i]);

      // arr√™t naturel
      if (Math.abs(ball.vx) < STOP_EPS) ball.vx = 0;
      if (Math.abs(ball.vy) < STOP_EPS) ball.vy = 0;

      if (ball.vx === 0 && ball.vy === 0){
        ball.active = false;
        endOfTurn();
      }
    }
  }

  // === Lumies ===
  for (let i=0;i<lumies.length;i++){
    const L = lumies[i];

    // int√©gration + frottements
    L.x += L.vx;
    L.y += L.vy;
    L.vx *= ROLL_F;
    L.vy *= ROLL_F;

    // estimation de la puissance d'impact murale (avant l'inversion)
    let wallImpact = 0;

    // murs (rebonds sur les 4 bords)
    if (L.x < L.r){
      L.x = L.r;
      wallImpact = Math.max(wallImpact, Math.abs(L.vx));
      L.vx = -L.vx * RESTIT;
    }
    if (L.x > canvas.width - L.r){
      L.x = canvas.width - L.r;
      wallImpact = Math.max(wallImpact, Math.abs(L.vx));
      L.vx = -L.vx * RESTIT;
    }
    if (L.y < L.r){
      L.y = L.r;
      wallImpact = Math.max(wallImpact, Math.abs(L.vy));
      L.vy = -L.vy * RESTIT;
    }
    if (L.y > canvas.height - L.r){
      L.y = canvas.height - L.r;
      wallImpact = Math.max(wallImpact, Math.abs(L.vy));
      L.vy = -L.vy * RESTIT;
    }

    // d√©clenchement couleur uniquement sur impact suffisant (et hors cooldown)
    if (wallImpact > 0){
      tryToggleOnImpact(L, wallImpact);
    }

    // seuil d'arr√™t
    if (Math.abs(L.vx) < STOP_EPS) L.vx = 0;
    if (Math.abs(L.vy) < STOP_EPS) L.vy = 0;
  }

  // === Collisions entre lumies ===
  for (let i=0;i<lumies.length;i++){
    for (let j=i+1;j<lumies.length;j++){
      collideLumies(lumies[i], lumies[j]); // doit appeler tryToggleOnImpact(A/B, |vn|)
    }
  }
}

function tryToggleOnImpact(L, impactPower){
  const now = performance.now();
  if ((L.colorLockUntil || 0) > now) return; // encore verrouill√©e
  if (impactPower < IMPACT_MIN) return;      // impact trop faible

  onLumieHit(L);                              // applique la r√®gle
  L.colorLockUntil = now + COLOR_COOLDOWN;    // verrou 4 s
  L.lastHit = now;                            // √©vite re-toggle par une autre voie
}


function collideBallLumie(B, L){
  // vecteur centre-centre
  let dx = L.x - B.x, dy = L.y - B.y;
  let d  = Math.hypot(dx, dy);
  const minD = B.r + L.r;
  if (d === 0){ dx = 1e-6; d = 1e-6; }
  if (d >= minD) return;

  // normale + correction de p√©n√©tration
  const nx = dx / d, ny = dy / d;
  const overlap = minD - d;
  B.x -= nx * overlap * 0.5; B.y -= ny * overlap * 0.5;
  L.x += nx * overlap * 0.5; L.y += ny * overlap * 0.5;

  // vitesse relative projet√©e sur la normale
  const rvx = B.vx - L.vx, rvy = B.vy - L.vy;
  const vn  = rvx * nx + rvy * ny;           // < 0 si approche / > 0 si s√©paration
  if (vn >= 0) return;                        // pas d'impact (on ignore)

  // puissance d'impact AVANT l'impulsion
  const impactPower = Math.abs(vn);

  // impulsion √©lastique (masses √©gales)
  const j  = -(1 + RESTIT) * vn / 2;
  const jx = j * nx, jy = j * ny;
  B.vx -= jx; B.vy -= jy;
  L.vx += jx; L.vy += jy;

  // tentative de bascule couleur contr√¥l√©e par lock/cooldown + seuil
  tryToggleOnImpact(L, impactPower);
}

function collideLumies(A,B){
  let dx = B.x - A.x, dy = B.y - A.y;
  let d  = Math.hypot(dx,dy);
  const minD = A.r + B.r;
  if (d === 0){ dx = 1e-6; d = 1e-6; }
  if (d >= minD) return;

  const nx = dx / d, ny = dy / d;
  const overlap = minD - d;

  // s√©paration
  A.x -= nx * overlap * 0.5; A.y -= ny * overlap * 0.5;
  B.x += nx * overlap * 0.5; B.y += ny * overlap * 0.5;

  // vitesse relative le long de la normale
  const rvx = A.vx - B.vx, rvy = A.vy - B.vy;
  const vn  = rvx * nx + rvy * ny;      // < 0 si elles se percutent

  if (vn >= 0) return;                  // pas d'impact

  const impactPower = Math.abs(vn);

  // impulsion √©lastique (masses √©gales)
  const j  = -(1 + RESTIT) * vn / 2;
  const jx = j * nx, jy = j * ny;
  A.vx -= jx; A.vy -= jy;
  B.vx += jx; B.vy += jy;

  // bascule couleur contr√¥l√©e (seuil + cooldown)
  tryToggleOnImpact(A, impactPower);
  tryToggleOnImpact(B, impactPower);
}


/* End turn + narration */
function endOfTurn(){
  // calcul fiable √† partir du snapshot
  const {gained, lost} = computeGainedLost(currentPlayer);

  // narration
  buildNarrationForTurn(gained, lost);

  // r√®gle rejouer
  if(!playerColors[1]){
    currentPlayer = (currentPlayer===1)?2:1;
  } else if(gained>0 && lost===0){
    // rejoue
  } else {
    currentPlayer = (currentPlayer===1)?2:1;
  }

  repositionBall(); updateBadge();

  // robot
  if(gameMode!=='pvp' && currentPlayer===2 && !gameOver){
    setTimeout(robotPlay, 800);
  }

  // nouveau tour : snapshot & unlock
  startTurn();
}

function buildNarrationForTurn(gained, lost){
  const teamCol = playerColors[1] ? playerColors[currentPlayer] : (currentPlayer===1?'green':'blue');
  const teamFr  = (teamCol==='green')?'verte':'bleue';

  let msg = "L‚Äô√©quipe " + teamFr + " a lanc√© le Luminator";
  if(changesThisTurn.length===0){
    msg += " sans transformer de Lumie. ";
  }else if(changesThisTurn.length===1){
    const c = changesThisTurn[0];
    const toFr = (c.after==='green')?'verte':'bleue';
    if(c.before==='red'){ msg += " sur une Lumie rouge devenue al√©atoirement " + toFr + ". "; }
    else { msg += " sur une Lumie devenue " + toFr + ". "; }
  }else{
    const reds = changesThisTurn.some(c=>c.before==='red');
    const toGreen = changesThisTurn.filter(c=>c.after==='green').length;
    const toBlue  = changesThisTurn.filter(c=>c.after==='blue').length;
    msg += " sur plusieurs Lumies ";
    if(reds) msg += "(dont des rouges) ";
    msg += "devenues ";
    if(toGreen && toBlue) msg += "vertes et bleues. ";
    else if(toGreen) msg += "vertes. ";
    else if(toBlue)  msg += "bleues. ";
  }

  const replay = (playerColors[1]) ? (gained>0 && lost===0) : false;
  msg += replay ? "Elle rejoue." : "Elle ne rejoue pas.";
  narrationEl.textContent = msg;

  // reset des changements m√©moris√©s pour la phrase
  changesThisTurn.length = 0;
}

function repositionBall(){
  const midX=canvas.width*0.5;
  //const launchOffset=Math.max(56, canvas.height*0.14);
  const launchOffset = MOBILE
    ? Math.max(80, MOBILE_LAUNCH_MARGIN)
    : Math.max(56, canvas.height * 0.14);

  if(currentPlayer===1){ ball.x=midX; ball.y=canvas.height-launchOffset; }
  else { ball.x=midX; ball.y=launchOffset; }
  ball.vx=0; ball.vy=0; ball.active=false;
}

/* Robot */
function robotPlay(){
  if(gameOver) return;
  let target = null;

  if(gameMode === 'easy' || !playerColors[1]){
    target = lumies[Math.floor(Math.random()*lumies.length)];
  } else {
    const myCol = playerColors[2];
    const candidates = lumies.filter(l => l.color !== myCol);
    target = (candidates.length? candidates[Math.floor(Math.random()*candidates.length)]
                               : lumies[Math.floor(Math.random()*lumies.length)]);
  }

  const dx = target.x - ball.x;
  const dy = target.y - ball.y;
  const len = Math.hypot(dx,dy) || 1;
  const ux = dx/len, uy = dy/len;

  let power;
  if(gameMode === 'easy'){
    power = 0.45 + Math.random()*0.25;
  } else if (gameMode === 'hard'){
    power = 0.65 + Math.random()*0.25;
  } else {
    power = 0.6;
  }
  const speed = MAX_DRAG * POWER_K * power;

  ball.vx = ux * speed;
  ball.vy = uy * speed;
  ball.active = true;
  ball.age = 0;
}

/* Rendering */
function drawDashed(x1,y1,x2,y2,seg,space){
  let dx=x2-x1, dy=y2-y1, len=Math.hypot(dx,dy); if(len===0) return;
  const maxLen = MAX_AIM_LEN;
  if(len>maxLen){ const sc=maxLen/len; dx*=sc; dy*=sc; len=maxLen; x2=x1+dx; y2=y1+dy; }
  const nx=dx/len, ny=dy/len; let d=0, on=true, cx=x1, cy=y1;
  while(d<len){ let step=(on?seg:space); if(d+step>len) step=len-d; const sx=nx*step, sy=ny*step;
    if(on){ ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+sx,cy+sy); ctx.stroke(); }
    cx+=sx; cy+=sy; d+=step; on=!on;
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(mode==="night"){
    const g=ctx.createRadialGradient(canvas.width*.5,canvas.height*.5,10,canvas.width*.5,canvas.height*.5,Math.max(canvas.width,canvas.height)*.8);
    g.addColorStop(0,'#16224a'); g.addColorStop(1,'#0b1020'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  } else {
    const g2=ctx.createLinearGradient(0,0,0,canvas.height);
    g2.addColorStop(0,'#6abf69'); g2.addColorStop(1,'#2e7d32'); ctx.fillStyle=g2; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  const rBase=Math.min(canvas.width,canvas.height)*0.10;
  ctx.beginPath(); ctx.arc(canvas.width*.5,56, rBase, Math.PI, 0, false); ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fill();
  ctx.beginPath(); ctx.arc(canvas.width*.5,canvas.height, rBase, 0, Math.PI, false); ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fill();

  ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(canvas.width*.06, canvas.height*.5); ctx.lineTo(canvas.width*.94, canvas.height*.5); ctx.stroke();

  for(let i=0;i<lumies.length;i++){
    const L=lumies[i];
    ctx.beginPath(); ctx.arc(L.x,L.y,L.r*1.5,0,Math.PI*2); ctx.fillStyle='rgba(255,90,103,0.20)'; ctx.fill();
    const fill=(L.color==='red')?COLOR_RED:(L.color==='green'?COLOR_GREEN:COLOR_BLUE);
    ctx.beginPath(); ctx.arc(L.x,L.y,L.r,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill();
    ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.stroke();
  }

  if(ball){
    ctx.beginPath(); ctx.arc(ball.x,ball.y,R_BALL,0,Math.PI*2); ctx.fillStyle=COLOR_GOLD; ctx.fill();
    ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.75)'; ctx.stroke();
    if(showHint){
      ctx.font="18px Arial"; ctx.textAlign="center"; ctx.textBaseline="bottom";
      ctx.fillStyle="#fff";
      ctx.fillText("Lancez la balle en visant les boules", ball.x, ball.y - R_BALL - 20);
    }
  }

  if(drag){
    ctx.strokeStyle='rgba(255,255,255,0.55)'; ctx.lineWidth=2;
    drawDashed(drag.sx,drag.sy,drag.x,drag.y,6,6);
    const vx=drag.x-drag.sx, vy=drag.y-drag.sy, ang=Math.atan2(vy,vx);
    const ax=drag.x, ay=drag.y, l=12;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - l*Math.cos(ang - Math.PI/6), ay - l*Math.sin(ang - Math.PI/6));
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - l*Math.cos(ang + Math.PI/6), ay - l*Math.sin(ang + Math.PI/6));
    ctx.stroke();
  }

  for(let i=0;i<confetti.length;i++){
    const p=confetti[i]; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
    ctx.fillStyle=p.clr; ctx.fillRect(-p.size*0.5,-p.size*0.5,p.size,p.size); ctx.restore();
  }

  if(performance.now() < lumiosBallUntil){
    ctx.save();
    const cx=canvas.width/2, cy=canvas.height/2;
    ctx.font = Math.floor(Math.min(canvas.width,canvas.height)*0.10)+'px Arial Black';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.lineWidth=6;
    ctx.strokeText('BALLE DE LUMIOS', cx, cy);
    ctx.fillText('BALLE DE LUMIOS', cx, cy);
    ctx.restore();
  }

  if(gameOver){
    const cx=canvas.width/2, cy=canvas.height/2, R=Math.min(canvas.width,canvas.height)*0.30;
    ctx.fillStyle='#ffffff'; ctx.beginPath();
    const spikes=14; for(let k=0;k<spikes;k++){const a=(k/spikes)*Math.PI*2, r=(k%2?R*0.55:R), x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r; (k?ctx.lineTo(x,y):ctx.moveTo(x,y));}
    ctx.closePath(); ctx.fill();
    ctx.font=Math.floor(R*0.45)+'px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle=(winColor==='green')?COLOR_GREEN:COLOR_BLUE; ctx.fillText('LUMIOS',cx,cy);
  }
}

/* Timer + loop */
setInterval(function(){
  const sTot=Math.floor((Date.now()-tStart)/1000);
  const m=Math.floor(sTot/60), s=sTot%60;
  hudClock.textContent=(m<10?'0':'')+m+':'+(s<10?'0':'')+s;
},1000);

function loop(){ step(); draw(); requestAnimationFrame(loop); }
sizeCanvas(); resetGame(); loop();
</script>
</body>
</html>
